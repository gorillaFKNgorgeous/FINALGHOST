# aura/schemas.py
"""
Comprehensive and unified Pydantic data schemas for the Aura Mastering Application.
This file serves as the SINGLE SOURCE OF TRUTH for all analysis results and mastering parameters.
It is designed to be the definitive contract for all modules and the AI agent's output.

Revision 2: This version is complete, incorporating all necessary supporting models
to align with the existing processing code and resolve all ImportErrors.
"""
from __future__ import annotations

import logging
from typing import Optional, List, Any, Literal

from pydantic import BaseModel, Field, ConfigDict, PositiveFloat, NonNegativeFloat, conint

logger = logging.getLogger(__name__)

# ==============================================================================
# 1. ANALYSIS SCHEMAS
# These models structure the data generated by the analysis engine.
# ==============================================================================

class FileInfoModel(BaseModel):
    """Detailed information about an audio file."""
    filename: str = Field(..., description="Original filename of the audio file.")
    duration_seconds: NonNegativeFloat = Field(..., description="Duration of the audio file in seconds.")
    samplerate: int = Field(..., gt=0, description="Sample rate in Hz.")
    channels: int = Field(..., gt=0, description="Number of audio channels.")
    frames: int = Field(..., gt=0, description="Total number of frames in the audio file.")
    format_name: str = Field(..., description="Full format name (e.g., 'WAV (Microsoft)', 'FLAC').")
    subtype_name: str = Field(..., description="Subtype format (e.g., 'PCM_16', 'FLOAT').")
    file_size_mb: Optional[NonNegativeFloat] = Field(None, description="File size in Megabytes.")
    exists: bool = Field(True, description="Indicates if the file was successfully read.")
    error_message: Optional[str] = Field(None, description="Error message if file loading or info retrieval failed.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class BaseMetricsModel(BaseModel):
    """Common base for audio metrics to ensure consistency."""
    integrated_lufs: Optional[float] = Field(None, description="Integrated loudness in LUFS (EBU R128).")
    loudness_range_lra: Optional[NonNegativeFloat] = Field(None, description="Loudness Range (LRA) in LU (EBU R128).")
    true_peak_dbfs: Optional[float] = Field(None, description="True peak level in dBFS (4x oversampled).")
    sample_peak_dbfs: Optional[float] = Field(None, description="Sample peak level in dBFS (max absolute sample value).")
    crest_factor_overall: Optional[NonNegativeFloat] = Field(None, description="Overall Crest Factor (Peak-to-RMS ratio).")
    peak_to_loudness_ratio_plr: Optional[NonNegativeFloat] = Field(None, description="Peak to Loudness Ratio (PLR) in LU.")
    stereo_correlation_overall: Optional[float] = Field(None, ge=-1.0, le=1.0, description="Overall stereo correlation coefficient.")
    stereo_correlation_low_band: Optional[float] = Field(None, ge=-1.0, le=1.0, description="Stereo correlation for low frequencies.")
    stereo_correlation_mid_band: Optional[float] = Field(None, ge=-1.0, le=1.0, description="Stereo correlation for mid frequencies.")
    stereo_correlation_high_band: Optional[float] = Field(None, ge=-1.0, le=1.0, description="Stereo correlation for high frequencies.")
    channel_balance_rms_db: Optional[float] = Field(None, description="RMS level difference between Left and Right channels in dB (L-R).")
    channel_balance_peak_db: Optional[float] = Field(None, description="Peak level difference between Left and Right channels in dB (L-R).")
    spectral_centroid_hz: Optional[NonNegativeFloat] = Field(None, description="Spectral centroid in Hz.")
    spectral_bandwidth_hz: Optional[NonNegativeFloat] = Field(None, description="Spectral bandwidth in Hz.")
    spectral_contrast: Optional[Any] = Field(None, description="Spectral contrast (array of values per band).")
    spectral_flatness: Optional[NonNegativeFloat] = Field(None, description="Spectral flatness (tonality measure).")
    spectral_rolloff_hz: Optional[NonNegativeFloat] = Field(None, description="Spectral rolloff point in Hz.")
    zero_crossing_rate: Optional[NonNegativeFloat] = Field(None, description="Zero-crossing rate.")
    key_signature: Optional[str] = Field(None, description="Detected key signature (e.g., 'C# Minor').")
    key_confidence: Optional[NonNegativeFloat] = Field(None, le=1.0, description="Confidence of key detection (0.0 to 1.0).")
    tempo_bpm: Optional[PositiveFloat] = Field(None, description="Detected tempo in Beats Per Minute (BPM).")
    transient_density: Optional[NonNegativeFloat] = Field(None, description="Overall transient density (e.g., onsets per second).")
    transient_strength_avg_db: Optional[float] = Field(None, description="Average strength of detected transients in dB.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class GlobalMetricsModel(BaseMetricsModel):
    """Metrics calculated for the entire audio file."""
    pass

class SegmentRawMetricsModel(BaseMetricsModel):
    """Raw metrics calculated for a single audio segment."""
    pass

class DeviationsModel(BaseModel):
    """Deviations of segment metrics from global metrics."""
    integrated_lufs_diff_abs: Optional[float] = Field(None, description="Absolute difference in LUFS from global.")
    true_peak_dbfs_diff_abs: Optional[float] = Field(None, description="Absolute difference in True Peak dBFS from global.")
    spectral_centroid_hz_diff_percent: Optional[float] = Field(None, description="Percentage difference in Spectral Centroid from global.")
    model_config = ConfigDict(extra="allow", validate_assignment=True)

class SegmentMetricsModel(BaseModel):
    """Metrics for a single segment, including raw values and deviations."""
    segment_index: int = Field(..., ge=0, description="Index of the segment.")
    start_time_sec: NonNegativeFloat = Field(..., description="Start time of the segment in seconds.")
    end_time_sec: NonNegativeFloat = Field(..., description="End time of the segment in seconds.")
    raw_metrics: SegmentRawMetricsModel = Field(..., description="Raw metrics for this segment.")
    deviations_from_global: DeviationsModel = Field(..., description="Deviations of this segment's metrics from global averages.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class SlidingWindowAnalysisModel(BaseModel):
    """Analysis results from sliding window segmentation."""
    segment_length_sec: PositiveFloat = Field(..., description="Length of each segment in seconds.")
    overlap_ratio: NonNegativeFloat = Field(..., lt=1.0, description="Overlap ratio between segments (0.0 to <1.0).")
    segments: List[SegmentMetricsModel] = Field(..., description="List of analyzed segments.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class SectionModel(BaseModel):
    """A detected musical section (e.g., Verse, Chorus)."""
    name: str = Field(..., description="Name of the musical section (e.g., 'Verse 1', 'Chorus').")
    start_time_sec: NonNegativeFloat = Field(..., description="Start time of the section in seconds.")
    end_time_sec: NonNegativeFloat = Field(..., description="End time of the section in seconds.")
    confidence: float = Field(1.0, ge=0.0, le=1.0, description="Confidence in the section label (0.0 to 1.0).")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class MusicalSectionAnalysisModel(BaseModel):
    """Analysis results from musical section detection."""
    sections: List[SectionModel] = Field(..., description="List of detected musical sections.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class AISummaryModel(BaseModel):
    """Structured summary of the audio analysis for the AI planning agent."""
    schema_version: str = Field("1.0", description="Summary schema version.")
    overall_assessment: str = Field(..., description="Brief overall assessment of the track's characteristics.")
    global_metric_highlights: List[str] = Field(..., description="Key highlights or issues from global metrics.")
    problematic_segments_summary: List[str] = Field(..., description="Summary of problematic segments, cross-referenced with musical sections.")
    musical_structure_summary: str = Field(..., description="Summary of the detected musical structure.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class AnalysisResult(BaseModel):
    """Master model for the complete audio analysis output."""
    file_info: FileInfoModel = Field(..., description="Information about the analyzed file.")
    global_metrics: GlobalMetricsModel = Field(..., description="Global metrics for the entire track.")
    sliding_window_analysis: Optional[SlidingWindowAnalysisModel] = Field(None, description="Analysis of sliding window segments.")
    musical_section_analysis: Optional[MusicalSectionAnalysisModel] = Field(None, description="Analysis of detected musical sections.")
    ai_summary_input: Optional[AISummaryModel] = Field(None, description="Structured summary prepared as input for the AI agent.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)


# ==============================================================================
# 2. MASTERING PARAMETER SCHEMAS
# These models define the complete set of controllable parameters for the
# audio processing chain, aligned with the CURRENT IMPLEMENTATION.
# ==============================================================================

# --- 2.1 Individual Processor Settings Models ---

class EQBandModel(BaseModel):
    """Settings for a single Parametric EQ band."""
    freq_hz: PositiveFloat = Field(..., ge=20, le=20000, description="Center/corner frequency in Hz.")
    gain_db: float = Field(..., ge=-24, le=24, description="Gain in dB.")
    q: PositiveFloat = Field(..., ge=0.1, le=18, description="Q factor (bandwidth).")
    type: Literal['lowpass', 'highpass', 'peak', 'lowshelf', 'highshelf', 'notch'] = Field(..., description="Type of EQ filter.")
    slope_db_oct: Optional[conint(ge=6, le=48)] = Field(None, description="Filter slope for LPF/HPF in dB/octave.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class ParametricEQSettingsModel(BaseModel):
    """Settings for the Parametric EQ processor."""
    bands: List[EQBandModel] = Field(default_factory=list, description="List of EQ bands to apply.")
    linear_phase: bool = Field(False, description="If true, use linear phase filtering.")
    global_gain_db: float = Field(0.0, ge=-24, le=24, description="Overall gain adjustment for the EQ module in dB.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class DynamicEQBandModel(EQBandModel):
    """Settings for a single Dynamic EQ band."""
    threshold_db: float = Field(..., description="Threshold for dynamic action in dBFS.")
    ratio: PositiveFloat = Field(..., description="Ratio for dynamic action.")
    attack_ms: PositiveFloat = Field(..., description="Attack time in milliseconds.")
    release_ms: PositiveFloat = Field(..., description="Release time in milliseconds.")
    is_expansion: bool = Field(False, description="If true, band acts as an expander; otherwise, a compressor.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class DynamicEQSettingsModel(BaseModel):
    """Settings for the Dynamic EQ processor."""
    bands: List[DynamicEQBandModel] = Field(default_factory=list, description="List of Dynamic EQ bands.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class CompressorSettingsModel(BaseModel):
    """Settings for a single-band compressor."""
    threshold_db: float = Field(-18.0)
    ratio: PositiveFloat = Field(4.0)
    attack_ms: PositiveFloat = Field(10.0)
    release_ms: PositiveFloat = Field(100.0)
    knee_db: NonNegativeFloat= Field(0.0)
    makeup_gain_db: float = Field(0.0)
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class MultibandCompressorSettingsModel(BaseModel):
    """Settings for the Multiband Compressor processor."""
    low_mid_xover_hz: PositiveFloat = Field(120.0)
    mid_high_xover_hz: PositiveFloat = Field(5000.0)
    low_band: CompressorSettingsModel = Field(default_factory=lambda: CompressorSettingsModel(makeup_gain_db=2.0))
    mid_band: CompressorSettingsModel = Field(default_factory=lambda: CompressorSettingsModel(makeup_gain_db=2.0))
    high_band: CompressorSettingsModel = Field(default_factory=lambda: CompressorSettingsModel(makeup_gain_db=2.0))
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class SaturationSettingsModel(BaseModel):
    """Settings for the Saturation processor."""
    algorithm: Literal['tape', 'tube', 'transformer', 'arctan', 'tanh'] = Field('tape')
    drive_db: float = Field(0.0, ge=0.0, le=36.0)
    mix_percent: NonNegativeFloat = Field(100.0, le=100.0)
    output_gain_db: float = Field(0.0, ge=-24.0, le=24.0)
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class StereoWidthSettingsModel(BaseModel):
    """Settings for the Mid/Side Stereo Width processor."""
    width_factor: float = Field(1.0, ge=0.0, le=2.0)
    side_gain_db: float = Field(0.0, ge=-24.0, le=24.0)
    mid_gain_db: float = Field(0.0, ge=-24.0, le=24.0)
    side_shelf_hz: Optional[float] = Field(None, gt=20.0, le=20000.0)
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class DeesserSettingsModel(BaseModel):
    """Settings for the De-Esser processor."""
    split_freq_hz: PositiveFloat = Field(6000.0, ge=2000, le=12000)
    threshold_db: float = Field(-20.0)
    reduction_db: PositiveFloat = Field(6.0)
    attack_ms: PositiveFloat = Field(2.0)
    release_ms: PositiveFloat = Field(50.0)
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class TransientShaperSettingsModel(BaseModel):
    """Settings for the Transient Shaper processor."""
    attack_gain_db: float = Field(0.0, ge=-12.0, le=12.0)
    sustain_gain_db: float = Field(0.0, ge=-12.0, le=12.0)
    attack_ms: float = Field(10.0, ge=1.0, le=50.0)
    sustain_ms: float = Field(100.0, ge=20.0, le=500.0)
    mix: float = Field(1.0, ge=0.0, le=1.0)
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class LookaheadClipperSettingsModel(BaseModel):
    """Settings for the Lookahead Clipper / True Peak Limiter."""
    threshold_db: float = Field(-1.0, le=0.0)
    lookahead_ms: PositiveFloat = Field(1.5, gt=0)
    mode: Literal['hard', 'soft', 'tanh', 'tape'] = Field('hard')
    oversample_factor: Literal[2, 4, 8] = Field(2)
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

class DitherSettingsModel(BaseModel):
    """Settings for the Dithering processor."""
    high_pass: bool = Field(True, description="Enable high-pass shaping of dither noise.")
    model_config = ConfigDict(extra="forbid", validate_assignment=True)

# --- 2.2 The Unified MasteringParams Model (The AI's Target Schema) ---

class MasteringParams(BaseModel):
    """
    The definitive, unified Pydantic model for all mastering parameters.
    This is the primary contract for the AI agent.
    """
    model_config = ConfigDict(extra="forbid", validate_assignment=True, validate_default=True)

    # Global Output & Target Parameters
    target_lufs: float = Field(
        default=-14.0,
        ge=-24.0,
        le=-5.0,
        description="Target integrated loudness in LUFS. Spotify/YouTube standard",
    )
    lufs_normalize_on: bool = Field(
        default=True,
        description="Apply LUFS normalization when True",
    )
    output_bit_depth: Literal[32, 24, 16] = Field(32)

    # Processor Flags & Settings
    # AFTER THE FIX
    eq_on: bool = Field(True)
    eq_settings: Optional[ParametricEQSettingsModel] = Field(default_factory=lambda:ParametricEQSettingsModel())

    dynamic_eq_on: bool = Field(False)
    dynamic_eq_settings: Optional[DynamicEQSettingsModel] = Field(None)

    compressor_on: bool = Field(False)
    compressor_settings: Optional[CompressorSettingsModel] = Field(None)

    mb_comp_on: bool = Field(True)
    mb_comp_settings: Optional[MultibandCompressorSettingsModel] = Field(default_factory=lambda:MultibandCompressorSettingsModel())

    saturation_on: bool = Field(False)
    saturation_settings: Optional[SaturationSettingsModel] = Field(None)

    stereo_on: bool = Field(True)
    stereo_settings: Optional[StereoWidthSettingsModel] = Field(default_factory=lambda:StereoWidthSettingsModel())
    
    deesser_on: bool = Field(False)
    deesser_settings: Optional[DeesserSettingsModel] = Field(default_factory=lambda:DeesserSettingsModel())

    dither_on: bool = Field(True)
    dither_settings: Optional[DitherSettingsModel] = Field(default_factory=lambda:DitherSettingsModel())
    
    transient_on: bool = Field(False)
    transient_settings: Optional[TransientShaperSettingsModel] = Field(None)

    clipper_on: bool = Field(True)
    clipper_settings: Optional[LookaheadClipperSettingsModel] = Field(default_factory=lambda:LookaheadClipperSettingsModel())


# ==============================================================================
# 3. API & WORKER SCHEMAS
# These models are for job handling and communication between services.
# ==============================================================================

class JobCreationRequest(BaseModel):
    """Schema for a request to create a new mastering job."""
    original_filename: str
    original_file_gcs_path: str # Or local path for local worker
    user_intent_text: str

class JobStatusResponse(BaseModel):
    """Schema for responding with the status of a job."""
    job_id: str
    status: str # e.g., "queued", "analyzing", "complete", "error"
    stage: str # More granular stage within the status
    message: Optional[str] = None
    pct_complete: Optional[conint(ge=0, le=100)] = None
    timestamp_created: float
    timestamp_updated: float
    error_details: Optional[str] = None